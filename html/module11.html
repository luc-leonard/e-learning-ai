<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 11 â€” Les frontiÃ¨res qui tiennent</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ—ï¸</text></svg>">
</head>
<body>
  <div class="app">
    <div id="sidebar-root"></div>
    <main class="main-content">
      <div class="module-content">

<h1>Module 11 : Les frontiÃ¨res qui tiennent</h1>
<p class="module-subtitle"><em>Quand vos agrÃ©gats deviennent des Ãªtres vivants qui protÃ¨gent leurs propres rÃ¨gles</em></p>
<hr>
<h2>Ce que vous savez dÃ©jÃ </h2>
<p>Vos agrÃ©gats ont des invariants. Vos tests vÃ©rifient que ces invariants sont respectÃ©s. Mais les tests ne vÃ©rifient qu'<strong>aprÃ¨s coup</strong> â€” ils vous disent "Ã§a a cassÃ©", pas "Ã§a ne peut pas casser".</p>
<p>C'est la diffÃ©rence entre un garde-fou sur une falaise et un panneau "attention falaise" posÃ© 100 mÃ¨tres plus loin. Les deux sont utiles. Mais un seul empÃªche vraiment de tomber.</p>
<p>Ce module va transformer vos agrÃ©gats en garde-fous.</p>
<div class="module-meta">
<div class="module-meta-item"><strong>DurÃ©e :</strong> Une semaine (1-2 heures par jour)</div>
<div class="module-meta-item"><strong>Ce qu'il vous faut :</strong> Votre projet du Module 10, un compte Claude, votre carnet</div>
</div>
<hr>
<h2 id="m11-analogie">Avant de commencer : une analogie</h2>
<p>Vous allez dans un bureau de poste. Vous prenez un ticket numÃ©rotÃ©. Un Ã©cran affiche "NumÃ©ro 47, guichet 3". Le 47 va au guichet 3. Le 48 attend. Le 49 attend. Personne ne double.</p>
<p>Pourquoi est-ce que Ã§a marche ? Pas parce qu'il y a un rÃ¨glement affichÃ© au mur qui dit "ne doublez pas". Ã‡a marche parce que <strong>le systÃ¨me rend le doublage impossible</strong>. Vous ne pouvez pas aller au guichet sans votre numÃ©ro. Le guichet n'accepte qu'un client Ã  la fois. L'invariant "chaque client est servi dans l'ordre" n'est pas une rÃ¨gle Ã  respecter â€” c'est un fait structurel.</p>
<p>Maintenant, repensez Ã  votre application. Votre invariant "le nombre d'inscrits ne dÃ©passe pas le nombre de places" â€” est-il un panneau ou un garde-fou ? En ce moment, c'est un panneau. Le code vÃ©rifie, mais rien n'empÃªche <strong>structurellement</strong> de le violer. Si deux requÃªtes arrivent au mÃªme moment, si un bug saute la vÃ©rification, si quelqu'un modifie directement la base de donnÃ©es â€” l'invariant tombe.</p>
<p>Et si votre agrÃ©gat Ã©tait comme le bureau de poste ? Un systÃ¨me qui <strong>ne peut pas</strong> violer ses propres rÃ¨gles, par construction ?</p>
<p>En Elixir, c'est possible. Et c'est mÃªme naturel.</p>
<hr>
<div class="step-header" id="m11-jour1"><span class="step-number">1</span><h2>Le problÃ¨me de la base de donnÃ©es <small style="font-weight:400;font-size:0.65em;color:var(--text-tertiary)">(90 min)</small></h2></div>
<h3>Ce que vous allez faire</h3>
<p>Vous allez provoquer une violation d'invariant pour de vrai.</p>
<p>Demandez Ã  Claude :</p>
<blockquote>
<p>Voici le code de mon agrÃ©gat SÃ©ance :
[collez le code]</p>
<p>L'invariant dit : "le nombre d'inscrits ne dÃ©passe jamais le nombre de places."</p>
<p>Ã‰cris-moi un test qui simule deux inscriptions simultanÃ©es Ã  une sÃ©ance avec une seule place restante. Les deux requÃªtes arrivent en mÃªme temps, vÃ©rifient qu'il reste une place (oui pour les deux), et inscrivent toutes les deux.</p>
<p>Est-ce que mon code actuel empÃªche Ã§a ?</p>
</blockquote>
<div class="callout callout-red">
<div class="callout-title">ğŸ”´ Ce que vous allez dÃ©couvrir</div>
<p>Probablement que non. Voici pourquoi :</p>
<pre><code>Moment 1 : RequÃªte A vÃ©rifie â†’ il reste 1 place âœ“
Moment 2 : RequÃªte B vÃ©rifie â†’ il reste 1 place âœ“ (A n'a pas encore inscrit)
Moment 3 : RequÃªte A inscrit â†’ 0 places restantes
Moment 4 : RequÃªte B inscrit â†’ -1 places restantes â† INVARIANT VIOLÃ‰</code></pre>
<p>C'est le problÃ¨me du croissant du Module 2, mais en vrai dans le code. Vous l'aviez rÃ©solu conceptuellement avec la notion de rÃ©servation. Mais est-ce que le code l'implÃ©mente vraiment ?</p>
<h3>Pourquoi Ã§a arrive</h3>
<p>Votre agrÃ©gat est stockÃ© dans une base de donnÃ©es. Quand deux requÃªtes arrivent :</p>
<ol>
<li>Chacune <strong>lit</strong> l'Ã©tat de la sÃ©ance (nombre de places)</li>
<li>Chacune <strong>vÃ©rifie</strong> l'invariant dans son coin</li>
<li>Chacune <strong>Ã©crit</strong> son inscription</li>
</ol>
<p>Entre la lecture et l'Ã©criture, l'autre requÃªte a le temps de passer. La base de donnÃ©es ne sait pas que ces deux opÃ©rations font partie du mÃªme tout. Elle voit deux Ã©critures indÃ©pendantes.</p>
<p>C'est comme si deux boulangÃ¨res servaient le mÃªme croissant Ã  deux clients parce qu'elles regardent la vitrine chacune de leur cÃ´tÃ© sans se parler.</p>
<h3>La solution classique (et ses limites)</h3>
<p>La solution habituelle, c'est le <strong>verrouillage en base de donnÃ©es</strong> : on bloque la ligne "sÃ©ance" pendant qu'on inscrit, pour que personne d'autre ne puisse la lire en mÃªme temps. Ã‡a marche. Mais c'est fragile â€” il faut penser Ã  verrouiller Ã  chaque endroit, et si on oublie une seule fois, l'invariant peut Ãªtre violÃ©.</p>
<p>C'est un panneau. Pas un garde-fou.</p>
</div>
<hr>
<div class="step-header" id="m11-jour2"><span class="step-number">2</span><h2>Un agrÃ©gat qui vit en mÃ©moire <small style="font-weight:400;font-size:0.65em;color:var(--text-tertiary)">(2h)</small></h2></div>
<h3>L'idÃ©e clÃ©</h3>
<p>Et si votre agrÃ©gat n'Ã©tait pas juste des donnÃ©es dans une base ? Et s'il Ã©tait un <strong>programme en cours d'exÃ©cution</strong> â€” un processus vivant qui tourne en permanence, qui contient l'Ã©tat de la sÃ©ance, et qui est le <strong>seul</strong> Ã  pouvoir la modifier ?</p>
<p>Plus de lecture-vÃ©rification-Ã©criture en trois temps. Un seul interlocuteur qui reÃ§oit les demandes une par une, dans l'ordre, et qui dit oui ou non.</p>
<p>C'est exactement le bureau de poste. Le guichet (le processus) traite un client Ã  la fois. Personne ne double. L'invariant est garanti par construction.</p>
<p>En Elixir, ce concept existe nativement. Ã‡a s'appelle un <strong>GenServer</strong> â€” un processus qui :</p>
<ul>
<li>Vit en mÃ©moire tant qu'on en a besoin</li>
<li>Contient un Ã©tat (les donnÃ©es de la sÃ©ance)</li>
<li>ReÃ§oit des messages un par un (les demandes d'inscription)</li>
<li>Traite chaque message avant de passer au suivant</li>
</ul>
<h3>Ce que vous allez faire</h3>
<p>Demandez Ã  Claude :</p>
<blockquote>
<p>Explique-moi GenServer avec l'analogie du guichet de bureau de poste. Puis montre-moi comment transformer mon agrÃ©gat SÃ©ance en GenServer. Je veux :</p>
<ol>
<li>Quand une sÃ©ance est crÃ©Ã©e, un processus GenServer dÃ©marre</li>
<li>Le processus contient l'Ã©tat complet de la sÃ©ance (inscriptions incluses)</li>
<li>Pour inscrire quelqu'un, on envoie un message au processus</li>
<li>Le processus vÃ©rifie l'invariant et accepte ou refuse</li>
<li>Comme le processus traite les messages un par un, deux inscriptions simultanÃ©es sont traitÃ©es l'une aprÃ¨s l'autre â€” jamais en mÃªme temps</li>
</ol>
<p>Montre-moi le code et explique chaque partie.</p>
</blockquote>
<h3>Ce que Claude va vous montrer</h3>
<pre data-lang="elixir"><code>defmodule MonClub.Reunions.SeanceProcess do
  use GenServer

  # --- DÃ©marrage ---

  def start_link(seance) do
    GenServer.start_link(__MODULE__, seance, name: via(seance.id))
  end

  def init(seance) do
    # L'Ã©tat initial : la sÃ©ance avec ses donnÃ©es
    {:ok, seance}
  end

  # --- Interface publique (ce qu'on peut demander au guichet) ---

  def inscrire(seance_id, membre_id) do
    GenServer.call(via(seance_id), {:inscrire, membre_id})
  end

  def places_restantes(seance_id) do
    GenServer.call(via(seance_id), :places_restantes)
  end

  # --- Traitement des messages (ce que fait le guichet) ---

  def handle_call({:inscrire, membre_id}, _from, seance) do
    cond do
      seance.places_restantes &lt;= 0 -&gt;
        {:reply, {:error, :seance_complete}, seance}

      membre_deja_inscrit?(seance, membre_id) -&gt;
        {:reply, {:error, :deja_inscrit}, seance}

      true -&gt;
        seance_mise_a_jour = ajouter_inscription(seance, membre_id)
        {:reply, {:ok, :inscrit}, seance_mise_a_jour}
    end
  end

  def handle_call(:places_restantes, _from, seance) do
    {:reply, seance.places_restantes, seance}
  end
end</code></pre>
<h3>Ce que vous devez comprendre</h3>
<p>Lisez le <code>handle_call({:inscrire, ...})</code>. C'est le cÅ“ur du systÃ¨me.</p>
<p>Ce code ne vÃ©rifie pas la base de donnÃ©es. Il vÃ©rifie <strong>son propre Ã©tat en mÃ©moire</strong>. Et parce que GenServer traite les messages <strong>un par un</strong>, il est impossible que deux inscriptions soient traitÃ©es en mÃªme temps.</p>
<p>Rejouez le scÃ©nario du Jour 1 :</p>
<pre><code>Moment 1 : RequÃªte A envoie {:inscrire, marie} au processus
Moment 2 : RequÃªte B envoie {:inscrire, jean} au processus
Moment 3 : Le processus traite A â†’ il reste 1 place â†’ OK, Marie inscrite
Moment 4 : Le processus traite B â†’ il reste 0 places â†’ REFUSÃ‰</code></pre>
<p>B ne peut pas passer avant que A soit terminÃ©e. Le processus est le guichet. Un client Ã  la fois. L'invariant est garanti <strong>par construction</strong>, pas par vÃ©rification.</p>
<hr>
<div class="step-header" id="m11-jour3"><span class="step-number">3</span><h2>Que se passe-t-il quand le guichet plante ? <small style="font-weight:400;font-size:0.65em;color:var(--text-tertiary)">(90 min)</small></h2></div>
<h3>La question qui tue</h3>
<p>Votre sÃ©ance est un processus vivant. Et les processus vivants peuvent mourir â€” un bug, une erreur inattendue, un manque de mÃ©moire.</p>
<p>Que se passe-t-il si le processus de la SoirÃ©e Polar plante ? Toutes les donnÃ©es en mÃ©moire disparaissent. Les inscriptions, les places restantes â€” tout est perdu.</p>
<p>Ã‡a a l'air catastrophique. Mais Elixir a une rÃ©ponse Ã©lÃ©gante.</p>
<h3>L'analogie</h3>
<p>Vous Ãªtes dans un restaurant. Un serveur trÃ©buche et laisse tomber un plateau. Que se passe-t-il ?</p>
<p><strong>Option A (le monde fragile) :</strong> Le restaurant entier ferme. Tous les clients partent. Catastrophe.</p>
<p><strong>Option B (le monde Elixir) :</strong> Le gÃ©rant donne un nouveau plateau au serveur. Le serveur retourne en cuisine, recharge les plats, et reprend le service. Les autres serveurs n'ont mÃªme pas remarquÃ©.</p>
<p>C'est exactement ce que fait Elixir. Un processus plante ? Pas de problÃ¨me â€” un <strong>superviseur</strong> le redÃ©marre automatiquement. Le nouveau processus recharge son Ã©tat depuis la base de donnÃ©es et reprend lÃ  oÃ¹ l'autre s'est arrÃªtÃ©.</p>
<h3>Ce que vous allez faire</h3>
<p>Demandez Ã  Claude :</p>
<blockquote>
<p>Mon agrÃ©gat SÃ©ance est un GenServer. Que se passe-t-il s'il plante ?</p>
<p>Montre-moi :</p>
<ol>
<li>Comment crÃ©er un Supervisor qui surveille les processus de sÃ©ances</li>
<li>Quand un processus plante, comment il est redÃ©marrÃ© automatiquement</li>
<li>Comment le processus redÃ©marrÃ© rÃ©cupÃ¨re son Ã©tat depuis la base de donnÃ©es</li>
<li>Ce qui se passe pour le client qui avait envoyÃ© un message au moment du crash</li>
</ol>
</blockquote>
<h3>Ce que Claude va vous montrer</h3>
<pre data-lang="elixir"><code>defmodule MonClub.Reunions.Supervisor do
  use DynamicSupervisor

  def start_link(_) do
    DynamicSupervisor.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  def init(:ok) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  def demarrer_seance(seance_id) do
    # Charge la sÃ©ance depuis la base de donnÃ©es
    seance = Repo.get!(Seance, seance_id) |&gt; charger_inscriptions()

    # DÃ©marre un processus pour cette sÃ©ance
    DynamicSupervisor.start_child(__MODULE__, {SeanceProcess, seance})
  end
end</code></pre>
<h3>Ce que <code>:one_for_one</code> signifie</h3>
<p>La stratÃ©gie <code>:one_for_one</code> veut dire : "si un enfant plante, redÃ©marre <strong>seulement celui-lÃ </strong>". La SoirÃ©e Polar plante ? On redÃ©marre la SoirÃ©e Polar. Le Club Manga continue de tourner comme si de rien n'Ã©tait.</p>
<p>C'est comme dans le restaurant : un serveur trÃ©buche, les autres continuent. On ne ferme pas le restaurant.</p>
<h3>Le double filet</h3>
<p>Votre agrÃ©gat a maintenant deux niveaux de protection :</p>
<ol>
<li><strong>En fonctionnement normal</strong> : le processus protÃ¨ge les invariants en traitant les messages un par un</li>
<li><strong>En cas de crash</strong> : le superviseur redÃ©marre le processus, qui recharge son Ã©tat depuis la base de donnÃ©es</li>
</ol>
<p>La base de donnÃ©es est le <strong>backup</strong>. Le processus est le <strong>gardien</strong>. Les deux travaillent ensemble.</p>
<h3>Ce que vous devez noter dans votre carnet</h3>
<blockquote class="notebook-prompt">
<p>âœï¸ Comprenez-vous la diffÃ©rence entre "les donnÃ©es sont dans la base de donnÃ©es" et "les donnÃ©es sont dans un processus vivant" ?</p>
</blockquote>
<blockquote class="notebook-prompt">
<p>âœï¸ Pourquoi est-ce que traiter les messages un par un rÃ©sout le problÃ¨me des inscriptions simultanÃ©es ?</p>
</blockquote>
<blockquote class="notebook-prompt">
<p>âœï¸ Que se passe-t-il si le serveur entier plante (pas juste un processus) ? (RÃ©ponse : la base de donnÃ©es est toujours lÃ . Au redÃ©marrage, les processus rechargent depuis la base.)</p>
</blockquote>
<hr>
<div class="step-header" id="m11-jour4"><span class="step-number">4</span><h2>Synchroniser le processus et la base <small style="font-weight:400;font-size:0.65em;color:var(--text-tertiary)">(2h)</small></h2></div>
<h3>Le problÃ¨me</h3>
<p>Le processus vit en mÃ©moire. La base de donnÃ©es est sur le disque. Les deux contiennent les donnÃ©es de la sÃ©ance. Et ils peuvent se dÃ©synchroniser.</p>
<p>Exemple :</p>
<ol>
<li>Le processus inscrit Marie (en mÃ©moire : 2 places restantes)</li>
<li>Le processus Ã©crit dans la base de donnÃ©es... mais la base est lente</li>
<li>Le processus plante avant que l'Ã©criture soit terminÃ©e</li>
<li>Le superviseur redÃ©marre le processus</li>
<li>Le processus recharge depuis la base â†’ Marie n'est pas inscrite, 3 places restantes</li>
<li>Marie est perdue.</li>
</ol>
<h3>Ce que vous allez faire</h3>
<p>Demandez Ã  Claude :</p>
<blockquote>
<p>Mon agrÃ©gat SÃ©ance est un GenServer qui Ã©crit dans la base de donnÃ©es. Comment garantir que l'Ã©tat en mÃ©moire et l'Ã©tat en base sont toujours synchronisÃ©s ? Quelles sont les stratÃ©gies possibles et laquelle est la plus simple pour commencer ?</p>
</blockquote>
<h3>Les stratÃ©gies</h3>
<p>Claude va vous en proposer plusieurs. Voici les principales :</p>
<p><strong>StratÃ©gie 1 : Ã‰crire d'abord, mettre Ã  jour en mÃ©moire ensuite.</strong>
Le processus Ã©crit dans la base, et seulement si l'Ã©criture rÃ©ussit, il met Ã  jour son Ã©tat en mÃ©moire. Si la base refuse (contrainte violÃ©e), l'Ã©tat en mÃ©moire ne change pas.</p>
<pre data-lang="elixir"><code>def handle_call({:inscrire, membre_id}, _from, seance) do
  # VÃ©rifier les invariants en mÃ©moire (rapide)
  if seance.places_restantes &lt;= 0 do
    {:reply, {:error, :seance_complete}, seance}
  else
    # Ã‰crire dans la base (source de vÃ©ritÃ©)
    case Repo.insert(inscription) do
      {:ok, _} -&gt;
        # L'Ã©criture a rÃ©ussi â†’ mettre Ã  jour la mÃ©moire
        seance = %{seance | places_restantes: seance.places_restantes - 1}
        {:reply, {:ok, :inscrit}, seance}
      {:error, _} -&gt;
        # L'Ã©criture a Ã©chouÃ© â†’ ne rien changer en mÃ©moire
        {:reply, {:error, :erreur_base}, seance}
    end
  end
end</code></pre>
<p><strong>StratÃ©gie 2 : L'Ã©tat en mÃ©moire fait foi, on synchronise en arriÃ¨re-plan.</strong>
Plus performant mais plus complexe. On y reviendra.</p>
<p>Pour l'instant, la stratÃ©gie 1 est la bonne. Elle est simple et fiable.</p>
<h3>La rÃ¨gle</h3>
<p><strong>La base de donnÃ©es est la source de vÃ©ritÃ©. Le processus est le gardien rapide.</strong></p>
<p>Le processus vÃ©rifie les invariants en mÃ©moire (rapide, pas de rÃ©seau). Puis il Ã©crit dans la base (lent, mais durable). Si l'Ã©criture Ã©choue, il ne modifie pas sa mÃ©moire.</p>
<p>Au redÃ©marrage, le processus recharge depuis la base. Comme la base est toujours Ã  jour, rien n'est perdu.</p>
<hr>
<div class="step-header" id="m11-jour5"><span class="step-number">5</span><h2>L'arbre de supervision complet <small style="font-weight:400;font-size:0.65em;color:var(--text-tertiary)">(90 min)</small></h2></div>
<h3>Ce que vous allez faire</h3>
<p>Vous avez un superviseur pour les sÃ©ances. Mais votre application a d'autres agrÃ©gats â€” les prÃªts, par exemple. Chaque agrÃ©gat mÃ©rite son propre processus et son propre superviseur.</p>
<p>Demandez Ã  Claude :</p>
<blockquote>
<p>Voici la liste de mes agrÃ©gats :</p>
<ul>
<li>SÃ©ance (gÃ¨re les inscriptions, la liste d'attente)</li>
<li>PrÃªt (gÃ¨re l'emprunt, le retour, les relances)</li>
</ul>
<p>Montre-moi l'arbre de supervision complet de mon application. Quel superviseur gÃ¨re quoi ? Comment les processus sont-ils organisÃ©s ?</p>
</blockquote>
<h3>Ce que Claude va vous montrer</h3>
<pre><code>MonClub.Application (superviseur racine)
â”œâ”€â”€ MonClub.Repo (la base de donnÃ©es)
â”œâ”€â”€ MonClub.PubSub (le tableau d'affichage)
â”œâ”€â”€ MonClub.Reunions.Supervisor (supervise les sÃ©ances)
â”‚   â”œâ”€â”€ SeanceProcess "SoirÃ©e Polar"
â”‚   â”œâ”€â”€ SeanceProcess "Club Manga"
â”‚   â””â”€â”€ SeanceProcess "Atelier Ã‰criture"
â”œâ”€â”€ MonClub.Prets.Supervisor (supervise les prÃªts)
â”‚   â”œâ”€â”€ PretProcess "Le Nom de la Rose â†’ Marie"
â”‚   â””â”€â”€ PretProcess "Dune â†’ Jean"
â”œâ”€â”€ MonClub.Paiements.Listener (Ã©coute les Ã©vÃ©nements)
â”œâ”€â”€ MonClub.Notifications.Listener
â””â”€â”€ MonClub.Web.Endpoint (le serveur web)</code></pre>
<h3>Ce que vous devez remarquer</h3>
<p>C'est un <strong>arbre</strong>. Pas un plat de nouilles, pas un schÃ©ma avec des flÃ¨ches partout. Un arbre hiÃ©rarchique oÃ¹ chaque branche est indÃ©pendante.</p>
<p>Si toute la branche RÃ©unions plante ? Les PrÃªts continuent. Les Notifications continuent. Le site web continue. Le superviseur racine redÃ©marre la branche RÃ©unions, qui redÃ©marre ses sÃ©ances depuis la base.</p>
<p>Si une seule sÃ©ance plante ? Les autres sÃ©ances continuent. MÃªme les rÃ©unions ne sont pas affectÃ©es â€” juste cette sÃ©ance-lÃ .</p>
<p>C'est le principe du restaurant poussÃ© Ã  l'extrÃªme. Un serveur trÃ©buche â†’ on le relÃ¨ve. Toute la cuisine prend feu â†’ on ferme la cuisine mais la terrasse reste ouverte. Le bÃ¢timent s'effondre â†’ OK, lÃ  on a un problÃ¨me. Mais chaque niveau de l'arbre isole les problÃ¨mes du reste.</p>
<h3>Le vocabulaire</h3>
<table>
<thead>
<tr>
<th>Ce que vous voyez</th>
<th>Le vrai nom</th>
</tr>
</thead>
<tbody>
<tr>
<td>L'arbre entier</td>
<td><strong>Arbre de supervision</strong> (Supervision Tree)</td>
</tr>
<tr>
<td>Un nÅ“ud qui surveille</td>
<td><strong>Superviseur</strong> (Supervisor)</td>
</tr>
<tr>
<td>Un nÅ“ud qui travaille</td>
<td><strong>Worker</strong> (le GenServer)</td>
</tr>
<tr>
<td>"Si un enfant plante, on le redÃ©marre"</td>
<td>StratÃ©gie <strong>one_for_one</strong></td>
</tr>
<tr>
<td>"Si un enfant plante, on redÃ©marre tous les enfants"</td>
<td>StratÃ©gie <strong>one_for_all</strong></td>
</tr>
<tr>
<td>"L'application continue malgrÃ© le crash"</td>
<td><strong>TolÃ©rance aux pannes</strong> (Fault Tolerance)</td>
</tr>
</tbody>
</table>
<hr>
<div class="step-header" id="m11-jour6"><span class="step-number">6</span><h2>Relier les processus et les Ã©vÃ©nements <small style="font-weight:400;font-size:0.65em;color:var(--text-tertiary)">(90 min)</small></h2></div>
<h3>Ce que vous allez faire</h3>
<p>Au Module 9, vous avez mis en place PubSub pour que les modules communiquent par Ã©vÃ©nements. Maintenant, les agrÃ©gats sont des processus vivants. Les deux doivent travailler ensemble.</p>
<p>Quand le processus de la SoirÃ©e Polar inscrit Marie, il doit publier un Ã©vÃ©nement. Quand le Listener de Paiements reÃ§oit l'Ã©vÃ©nement, il doit crÃ©er le paiement.</p>
<p>Demandez Ã  Claude :</p>
<blockquote>
<p>Mon agrÃ©gat SÃ©ance est un GenServer. Quand une inscription rÃ©ussit, il doit publier un Ã©vÃ©nement via PubSub. Montre-moi comment intÃ©grer les deux :</p>
<ol>
<li>Le GenServer inscrit le membre et met Ã  jour la base</li>
<li>SEULEMENT si l'Ã©criture en base rÃ©ussit, il publie l'Ã©vÃ©nement</li>
<li>Le Listener de Paiements reÃ§oit l'Ã©vÃ©nement et crÃ©e le paiement</li>
</ol>
<p>Montre-moi aussi : que se passe-t-il si le processus plante ENTRE l'Ã©criture en base et la publication de l'Ã©vÃ©nement ?</p>
</blockquote>
<h3>Le code intÃ©grÃ©</h3>
<pre data-lang="elixir"><code>def handle_call({:inscrire, membre_id}, _from, seance) do
  if seance.places_restantes &lt;= 0 do
    {:reply, {:error, :seance_complete}, seance}
  else
    case Repo.insert(inscription) do
      {:ok, inscription} -&gt;
        # Base OK â†’ mettre Ã  jour la mÃ©moire
        seance = mettre_a_jour_places(seance)

        # MÃ©moire OK â†’ publier l'Ã©vÃ©nement
        Phoenix.PubSub.broadcast(MonClub.PubSub, "reunions",
          {:membre_inscrit, %{
            membre_id: membre_id,
            seance_id: seance.id,
            places_restantes: seance.places_restantes
          }}
        )

        {:reply, {:ok, :inscrit}, seance}

      {:error, changeset} -&gt;
        {:reply, {:error, :erreur_inscription}, seance}
    end
  end
end</code></pre>
<h3>La question difficile</h3>
<p>Que se passe-t-il si le processus plante <strong>aprÃ¨s</strong> l'Ã©criture en base mais <strong>avant</strong> la publication de l'Ã©vÃ©nement ? L'inscription est enregistrÃ©e, mais Paiements n'est jamais prÃ©venu. Marie est inscrite mais n'a pas payÃ©.</p>
<p>C'est un vrai problÃ¨me, et il n'a pas de solution magique. Les stratÃ©gies courantes :</p>
<ol>
<li><strong>Accepter le risque et rattraper.</strong> Un job pÃ©riodique vÃ©rifie les inscriptions sans paiement et publie les Ã©vÃ©nements manquants.</li>
<li><strong>Outbox pattern.</strong> On Ã©crit l'Ã©vÃ©nement dans la base de donnÃ©es en mÃªme temps que l'inscription (dans la mÃªme transaction), et un processus sÃ©parÃ© lit les Ã©vÃ©nements en base et les publie.</li>
</ol>
<p>Pour l'instant, la stratÃ©gie 1 suffit. Mais notez l'existence du problÃ¨me â€” c'est un des problÃ¨mes les plus fondamentaux de l'informatique distribuÃ©e, et il n'existe nulle part de solution parfaite. Juste des stratÃ©gies avec des compromis diffÃ©rents.</p>
<hr>
<div class="step-header" id="m11-jour7"><span class="step-number">7</span><h2>Le bilan</h2></div>
<h3>Ce que vous avez fait cette semaine</h3>
<p>Vous avez transformÃ© vos agrÃ©gats de <strong>donnÃ©es passives</strong> (stockÃ©es dans une base, vÃ©rifiÃ©es par des tests) en <strong>processus vivants</strong> (qui tournent en mÃ©moire, qui protÃ¨gent leurs invariants par construction, qui redÃ©marrent automatiquement en cas de crash).</p>
<h3>Le changement de paradigme</h3>
<table>
<thead>
<tr>
<th>Avant (Modules 8-10)</th>
<th>Maintenant (Module 11)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L'agrÃ©gat est un schÃ©ma de base de donnÃ©es</td>
<td>L'agrÃ©gat est un <strong>processus vivant</strong></td>
</tr>
<tr>
<td>Les invariants sont vÃ©rifiÃ©s dans le code</td>
<td>Les invariants sont <strong>garantis par construction</strong></td>
</tr>
<tr>
<td>Deux requÃªtes simultanÃ©es = risque</td>
<td>Deux requÃªtes simultanÃ©es = file d'attente</td>
</tr>
<tr>
<td>Un bug = Ã©tat incohÃ©rent</td>
<td>Un crash = redÃ©marrage automatique</td>
</tr>
<tr>
<td>La base de donnÃ©es est tout</td>
<td>La base de donnÃ©es est le <strong>backup</strong></td>
</tr>
</tbody>
</table>
<h3>Les mots de la semaine</h3>
<table>
<thead>
<tr>
<th>Ce que vous dites</th>
<th>Le vrai nom</th>
</tr>
</thead>
<tbody>
<tr>
<td>"Le guichet qui traite un client Ã  la fois"</td>
<td><strong>GenServer</strong></td>
</tr>
<tr>
<td>"Le gÃ©rant qui redÃ©marre les serveurs"</td>
<td><strong>Superviseur</strong> (Supervisor)</td>
</tr>
<tr>
<td>"L'arbre du restaurant"</td>
<td><strong>Arbre de supervision</strong> (Supervision Tree)</td>
</tr>
<tr>
<td>"La base est le backup, le processus est le gardien"</td>
<td><strong>Sourcing hybride</strong></td>
</tr>
<tr>
<td>"L'invariant ne peut pas Ãªtre violÃ©"</td>
<td><strong>Invariant structurel</strong> (vs invariant vÃ©rifiÃ©)</td>
</tr>
<tr>
<td>"Crash et redÃ©marrage, c'est normal"</td>
<td><strong>Let it crash</strong> (philosophie Erlang/Elixir)</td>
</tr>
</tbody>
</table>
<h3>La structure de votre application</h3>
<pre><code>MonClub.Application
â”œâ”€â”€ Repo (base de donnÃ©es = source de vÃ©ritÃ© durable)
â”œâ”€â”€ PubSub (Ã©vÃ©nements de domaine)
â”‚
â”œâ”€â”€ Reunions.Supervisor
â”‚   â””â”€â”€ SeanceProcess (GenServer)
â”‚       â”œâ”€â”€ Ã‰tat en mÃ©moire : sÃ©ance + inscriptions
â”‚       â”œâ”€â”€ Invariants : protÃ©gÃ©s par traitement sÃ©quentiel
â”‚       â”œâ”€â”€ Ã‰crit dans la base Ã  chaque modification
â”‚       â””â”€â”€ Publie les Ã©vÃ©nements aprÃ¨s Ã©criture rÃ©ussie
â”‚
â”œâ”€â”€ Prets.Supervisor
â”‚   â””â”€â”€ PretProcess (GenServer)
â”‚       â”œâ”€â”€ Ã‰tat en mÃ©moire : prÃªt + relances
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ Paiements.Listener (rÃ©agit aux Ã©vÃ©nements)
â”œâ”€â”€ Notifications.Listener
â””â”€â”€ Web.Endpoint</code></pre>
<hr>
<h2 id="m11-suite">La suite</h2>
<p>Votre application a des agrÃ©gats vivants, des Ã©vÃ©nements de domaine, des superviseurs. Elle est solide. Mais elle a une limitation : tout est dans un seul serveur. Un seul ordinateur qui fait tout.</p>
<p>Le Module 12 va vous amener au dernier niveau : que se passe-t-il quand vous avez besoin de plusieurs serveurs ? Comment les processus communiquent entre machines ? Comment les Ã©vÃ©nements traversent le rÃ©seau ? Elixir a Ã©tÃ© conÃ§u pour Ã§a depuis le dÃ©but â€” c'est le moment de le dÃ©couvrir.</p>

      </div>
    </main>
    <button class="back-to-top" aria-label="Retour en haut">â†‘</button>
  </div>
  <script src="nav.js"></script>
  <script src="app.js"></script>
</body>
</html>
